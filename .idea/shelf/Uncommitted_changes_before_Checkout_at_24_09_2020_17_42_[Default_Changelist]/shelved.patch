Index: custom_gym/Transition_model/drone_3d_trajectory_following.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nSimulate a quadrotor following a 3D trajectory\r\n\r\nAuthor: Daniel Ingram (daniel-s-ingram)\r\n\"\"\"\r\n\r\nfrom math import cos, sin\r\nimport numpy as np\r\nfrom Quadrotor import Quadrotor\r\nfrom TrajectoryGenerator import TrajectoryGenerator\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\nimport math\r\nfrom os import mkdir\r\nfrom os.path import join, isdir\r\nfrom my_utils import *\r\nfrom simple_pid import PID\r\nimport matplotlib\r\nimport matplotlib.pyplot as plt\r\nmatplotlib.use(\"Qt5agg\")\r\nfrom matplotlib.animation import FuncAnimation\r\nfrom Pid_plotter import PIDPlotter\r\nshow_animation = False\r\n\r\n\r\n\r\n# Simulation parameters\r\ng = 9.81\r\nm = 0.2\r\nIxx = 1\r\nIyy = 1\r\nIzz = 1\r\n\r\n\r\n\r\n\r\n#T = 5           #<---------------------------------\r\n\r\n\r\n\r\n\r\nacc_max_scalar = 3 #(m/s^2)\r\nvel_max_scalar = 18 #(m/s)\r\n\r\n# Proportional coefficients\r\n# Kp_x = 1\r\n# Kp_y = 1\r\nKp_z = 1\r\n\r\n\r\nKp_roll = 25\r\nKp_pitch = 25\r\nKp_yaw = 25\r\n\r\n# Derivative coefficients\r\n# Kd_x = 10\r\n# Kd_y = 10\r\nKd_z = 1\r\n\r\nwaypoints = [[10, 0, 10], [10, 500, 10], [10, 0, 10]]\r\nnum_waypoints = len(waypoints)\r\n\r\n\r\nKp_x_pos = 0.1\r\nKp_y_pos = 1\r\n\r\nKp_x_vel = 10\r\nKp_y_vel = 15\r\n\r\n\r\nKp_z_pos = 0.1\r\nKp_z_vel = 0.1\r\n\r\n\r\n        \r\ndef quad_sim(x_c, y_c, z_c):\r\n    \"\"\"\r\n    Calculates the necessary thrust and torques for the quadrotor to\r\n    follow the trajectory described by the sets of coefficients\r\n    x_c, y_c, and z_c.\r\n    \"\"\"\r\n    x_pos = waypoints[0][0]\r\n    y_pos = waypoints[0][1]\r\n    z_pos = waypoints[0][2]\r\n    x_vel = 0\r\n    y_vel = 0\r\n    z_vel = 0\r\n    x_acc = 0\r\n    y_acc = 0\r\n    z_acc = 0\r\n    roll = 0\r\n    pitch = 0\r\n    yaw = 0\r\n    roll_vel = 0\r\n    pitch_vel = 0\r\n    yaw_vel = 0\r\n\r\n    des_yaw = 0\r\n\r\n    dt = 0.1\r\n    t = 0\r\n    dist_goal = 0\r\n\r\n    quadrotor = Quadrotor(x=x_pos, y=y_pos, z=z_pos, roll=roll,\r\n                  pitch=pitch, yaw=yaw, size=1, show_animation=show_animation)\r\n\r\n    i = 0\r\n    n_run = num_waypoints-1 # Number of waypoint-waypoint flights\r\n    irun = 0\r\n\r\n    \r\n    while True:\r\n        start = waypoints[i]\r\n        next_goal = waypoints[(i+1) % num_waypoints]\r\n\r\n        goal_x = next_goal[0]\r\n        goal_y = next_goal[1]\r\n        goal_z = next_goal[2]\r\n\t\r\n        L = distance_2D(waypoints[i],waypoints[(i+1)%num_waypoints])\r\n        T = (L*acc_max_scalar + vel_max_scalar **2 ) /(acc_max_scalar * vel_max_scalar)\r\n        T_s = vel_max_scalar / acc_max_scalar\r\n \r\n        # acc_max_x, acc_max_y, acc_max_z = get_3D_components(waypoints[i],waypoints[(i+1)%num_waypoints],acc_max_scalar)\r\n        # vel_max_x, vel_max_y, vel_max_z = get_3D_components(waypoints[i],waypoints[(i+1)%num_waypoints],vel_max_scalar)\r\n \r\n        acc_max_x, acc_max_y = get_2D_components(waypoints[i],waypoints[(i+1)%num_waypoints],acc_max_scalar)\r\n        vel_max_x, vel_max_y = get_2D_components(waypoints[i],waypoints[(i+1)%num_waypoints],vel_max_scalar)\r\n\r\n        pid_x = PID(0.5, 0.1, 0.5, setpoint = goal_x)\r\n        pid_y = PID(0.5, 0.01, 0.6, setpoint = goal_y)\r\n        # pid_z = PID(1, 0.1, 0.0, setpoint = goal_z)\r\n        \r\n        pid_vel_x = PID(Kp_x_vel, 0.0, 0.0, setpoint = 0 )\r\n        pid_vel_y = PID(Kp_y_vel, 0.0, 0.0, setpoint = 0 )\r\n        dist_goal = distance_AB_2D(waypoints[i],waypoints[(i+1)%num_waypoints])\r\n        # while t <= T:\r\n        # while 0.5 <= dist_goal:\r\n            \r\n        plt.ion()\r\n        hl, = plt.plot([],[],c=\"b\")#,linestyle='dashed')\r\n        hl2, = plt.plot([],[],c=\"r\")\r\n        ax = plt.axes()\r\n        plt.show(block=False)\r\n\r\n        def _mypause(interval):\r\n            backend = plt.rcParams['backend']\r\n            if backend in matplotlib.rcsetup.interactive_bk:\r\n                figManager = matplotlib._pylab_helpers.Gcf.get_active()\r\n                if figManager is not None:\r\n                    canvas = figManager.canvas\r\n                    if canvas.figure.stale:\r\n                        canvas.draw()\r\n                    canvas.start_event_loop(interval)\r\n                    return\r\n\r\n        while True:\r\n            PosizioneAttuale = np.array([x_pos, y_pos, z_pos])\r\n            dist_goal = distance_AB_2D(PosizioneAttuale, next_goal)\r\n            dist_percorsa2D = distance_AB_2D(start, PosizioneAttuale)\r\n\r\n            if( not is_bang_cost_available( L,acc_max_scalar,vel_max_scalar) ):\r\n                raise Exception(\"Bang cost bang not feasible\")\r\n\r\n            print(\"running:\",\"{:.2f}\".format(t))\r\n        \r\n\r\n\r\n            # 3D TEST\r\n            \r\n            # des_x_pos, des_y_pos, des_z_pos = bang_position(x_pos,y_pos,z_pos,\r\n            #     acc_max_x,acc_max_y,acc_max_z,\r\n            #     vel_max_x,vel_max_y,vel_max_z,\r\n            #     t,T,T_s)\r\n\r\n            # des_x_vel, des_y_vel, des_z_vel = bang_velocity(acc_max_x,acc_max_y,acc_max_z,\r\n            #     vel_max_x,vel_max_y,vel_max_z,\r\n            #     t,T,T_s)\r\n\r\n            # des_x_acc, des_y_acc, des_z_acc = bang_accelleration(acc_max_x,acc_max_y,acc_max_z,\r\n            #     t,T,T_s)\r\n\r\n            # 2D TEST\r\n            \r\n            # des_x_pos, des_y_pos = bang_position_2D(x_pos,y_pos,\r\n            #     acc_max_x,acc_max_y,\r\n            #     t,T,T_s, goal_x, goal_y)\r\n\r\n            # des_x_vel, des_y_vel = bang_velocity_2D(acc_max_x,acc_max_y,\r\n            #     t,T,T_s)\r\n\r\n            des_x_acc, des_y_acc = bang_accelleration_2D(acc_max_x,acc_max_y,\r\n                t,T,T_s)\r\n\r\n            # ORIGINAL\r\n\r\n            # # des_x_pos = calculate_position(x_c[i], t)\r\n            # # des_y_pos = calculate_position(y_c[i], t)\r\n            des_z_pos = calculate_position(z_c[i], t)\r\n            # # des_x_vel = calculate_velocity(x_c[i], t)\r\n            # # des_y_vel = calculate_velocity(y_c[i], t)\r\n            des_z_vel = calculate_velocity(z_c[i], t)\r\n            # des_x_acc = calculate_acceleration(x_c[i], t)\r\n            # des_y_acc = calculate_acceleration(y_c[i], t)\r\n            des_z_acc = calculate_acceleration(z_c[i], t)\r\n\r\n            thrust = m * (g + des_z_acc + Kp_z * (des_z_pos -\r\n                                                  z_pos) + Kd_z * (des_z_vel - z_vel))\r\n\r\n            # roll_torque = Kp_roll * \\\r\n            #     (((des_x_acc * sin(des_yaw) - des_y_acc * cos(des_yaw)) / g) - roll)\r\n            # pitch_torque = Kp_pitch * \\\r\n            #     (((des_x_acc * cos(des_yaw) - des_y_acc * sin(des_yaw)) / g) - pitch)\r\n            # yaw_torque = Kp_yaw * (des_yaw - yaw)\r\n\r\n            # x_vel_pid = pid_x(x_pos,dt=dt)\r\n            # y_vel_pid = pid_y(y_pos,dt=dt)\r\n\r\n            x_vel_pid = Kp_x_pos * (goal_x - x_pos )\r\n            y_vel_pid = Kp_y_pos * (goal_y - y_pos )\r\n\r\n\r\n            # if(y_vel_pid > 18):\r\n            #     y_vel_pid = 18\r\n\r\n            pid_vel_x.setpoint = 0 #x_vel_pid \r\n            pid_vel_y.setpoint = 18 #y_vel_pid\r\n            \r\n            pitch_des = Kp_x_vel * ( 0 - x_vel)\r\n            roll_des = Kp_y_vel * (18 - y_vel)\r\n\r\n            # pitch_des = pid_vel_x(x_vel)\r\n            # roll_des = pid_vel_y(y_vel)\r\n\r\n            roll_torque = Kp_roll * (roll_des - roll )\r\n            pitch_torque = Kp_pitch * (pitch_des - pitch)\r\n            yaw_torque = Kp_yaw * (des_yaw - yaw)\r\n\r\n            roll_vel += roll_torque * dt / Ixx\r\n            pitch_vel += pitch_torque * dt / Iyy\r\n            yaw_vel += yaw_torque * dt / Izz\r\n\r\n            roll += roll_vel * dt\r\n            pitch += pitch_vel * dt\r\n            yaw += yaw_vel * dt\r\n\r\n            # noise = np.random.normal(0,1,3)\r\n            # R = rotation_matrix(roll + noise[0], pitch + noise[1], yaw + noise[2])\r\n            R = rotation_matrix(roll , pitch , yaw )\r\n            acc = (np.matmul(R, np.array( [0, 0, thrust.item()]).T) \\\r\n                - np.array([0, 0, m * g]).T) / m\r\n            \r\n            x_acc = acc[0]\r\n            y_acc = acc[1]\r\n            z_acc = acc[2]\r\n            # z_acc = 0\r\n\r\n            x_vel += x_acc * dt\r\n            y_vel += y_acc * dt\r\n            z_vel += z_acc * dt\r\n\r\n            x_pos += x_vel * dt\r\n            y_pos += y_vel * dt\r\n            z_pos += z_vel * dt\r\n\r\n            # #TODO: test\r\n            # if (T_s < t < T - T_s):\r\n            #     y_vel = 18\r\n            #     y_acc = 0\r\n\r\n            quadrotor.update_pose(x_pos, y_pos, z_pos, roll, pitch, yaw)\r\n            \r\n            acc_ms = math.sqrt(x_acc ** 2 + y_acc ** 2)\r\n            vel_ms = math.sqrt(x_vel ** 2 + y_vel ** 2)\r\n\r\n            # # # # # # # \r\n            # Log info\r\n            print(\"X_pos:\",\"{:.2f}\".format(x_pos) ,\"\\tX_vel (m/s):\", \"{:.2f}\".format(x_vel), \"\\tX_acc (m/s^2):\", \"{:.2f}\".format(x_acc))\r\n            print(\"Y_pos:\",\"{:.2f}\".format(y_pos) ,\"\\tY_vel (m/s):\", \"{:.2f}\".format(y_vel), \"\\tY_acc (m/s^2):\", \"{:.2f}\".format(y_acc))\r\n            print(\"Z_pos:\",\"{:.2f}\".format(z_pos) ,\"\\tZ_vel (m/s):\", \"{:.2f}\".format(z_vel), \"\\tZ_acc (m/s^2):\", \"{:.2f}\".format(z_acc))\r\n            print(\"Acceleration:\", \"{:.2f}\".format(acc_ms))\r\n            print(\"Velocity (m/s):\", \"{:.2f}\".format(vel_ms))\r\n            print(\"L:\", L)\r\n            print(\"dist_goal:\", dist_goal)\r\n            print(\"dist_percorsa2D\", dist_percorsa2D)\r\n            \r\n            # Plot PID\r\n            # pid_plotter = PIDPlotter(500)\r\n            # ani = FuncAnimation(plt.gcf(), pid_plotter.animate, interval=pid_plotter.pause)\r\n            # plt.tight_layout()\r\n            # plt.show()\r\n            # ax = plt.gca()\r\n            \r\n            # \"\"\"\r\n            hl.set_xdata(np.append(hl.get_xdata(),t))\r\n            hl.set_ydata(np.append(hl.get_ydata(),y_vel))\r\n            \r\n            hl2.set_xdata(np.append(hl2.get_xdata(),t))\r\n            hl2.set_ydata(np.append(hl2.get_ydata(),18 ) )\r\n\r\n            \r\n            ax.relim() \r\n            ax.autoscale_view()             \r\n            \r\n            # plt.draw()\r\n            # plt.pause(0.001)\r\n            plt.draw()\r\n            _mypause(0.01)\r\n            # \"\"\"\r\n\r\n            \"\"\"\r\n            pid_plotter = PIDPlotter(0.1)\r\n            pid_plotter.drawLine(pid_plotter.hl,t,goal_y-y_pos)\r\n            pid_plotter.drawLine(pid_plotter.hl2,t,goal_y)\r\n            pid_plotter.animate()\r\n            \"\"\"\r\n\r\n\r\n            # # # # # # # # \r\n            \r\n            t += dt\r\n        \r\n        print(\"-\"*20,\"[REACHED, Missing\",distance_2D([x_pos,y_pos,z_pos],waypoints[(i+1)%num_waypoints]), \"m]\",\"-\"*20)\r\n        \r\n        t = 0\r\n        i = (i + 1) % 4\r\n        irun += 1\r\n        if irun >= n_run:\r\n            break\r\n        print(\"-\"*20,\"[PASSING TO NEXT WAYPOINT]\",\"-\"*20)\r\n\r\n    print(\"-\"*20,\"MISSION COMPLETE\",\"-\"*20)\r\n\r\n\r\ndef calculate_position(c, t):\r\n    \"\"\"\r\n    Calculates a position given a set of quintic coefficients and a time.\r\n\r\n    Args\r\n        c: List of coefficients generated by a quintic polynomial \r\n            trajectory generator.\r\n        t: Time at which to calculate the position\r\n\r\n    Returns\r\n        Position\r\n    \r\n    \"\"\"\r\n    return c[0] * t**5 + c[1] * t**4 + c[2] * t**3 + c[3] * t**2 + c[4] * t + c[5]\r\n\r\n\r\ndef calculate_velocity(c, t):\r\n    \"\"\"\r\n    Calculates a velocity given a set of quintic coefficients and a time.\r\n\r\n    Args\r\n        c: List of coefficients generated by a quintic polynomial \r\n            trajectory generator.\r\n        t: Time at which to calculate the velocity\r\n\r\n    Returns\r\n        Velocity\r\n    \"\"\"\r\n    return 5 * c[0] * t**4 + 4 * c[1] * t**3 + 3 * c[2] * t**2 + 2 * c[3] * t + c[4]\r\n\r\n\r\ndef calculate_acceleration(c, t):\r\n    \"\"\"\r\n    Calculates an acceleration given a set of quintic coefficients and a time.\r\n\r\n    Args\r\n        c: List of coefficients generated by a quintic polynomial \r\n            trajectory generator.\r\n        t: Time at which to calculate the acceleration\r\n\r\n    Returns\r\n        Acceleration\r\n    \"\"\"\r\n    return 20 * c[0] * t**3 + 12 * c[1] * t**2 + 6 * c[2] * t + 2 * c[3]\r\n\r\n\r\ndef rotation_matrix(roll, pitch, yaw):\r\n    \"\"\"\r\n    Calculates the ZYX rotation matrix.\r\n\r\n    Args\r\n        Roll: Angular position about the x-axis in radians.\r\n        Pitch: Angular position about the y-axis in radians.\r\n        Yaw: Angular position about the z-axis in radians.\r\n\r\n    Returns\r\n        3x3 rotation matrix as NumPy array\r\n    \"\"\"\r\n    return np.array(\r\n        [[cos(yaw) * cos(pitch), -sin(yaw) * cos(roll) + cos(yaw) * sin(pitch) * sin(roll), sin(yaw) * sin(roll) + cos(yaw) * sin(pitch) * cos(roll)],\r\n         [sin(yaw) * cos(pitch), cos(yaw) * cos(roll) + sin(yaw) * sin(pitch) *\r\n          sin(roll), -cos(yaw) * sin(roll) + sin(yaw) * sin(pitch) * cos(roll)],\r\n         [-sin(pitch), cos(pitch) * sin(roll), cos(pitch) * cos(yaw)]\r\n         ])\r\n\r\n\r\ndef is_bang_cost_available(L,acc_max,vel_max):\r\n    return L > vel_max ** 2 / acc_max\r\n\r\n\r\ndef bang_position(x_pos,y_pos,z_pos,\r\n    acc_max_x,acc_max_y,acc_max_z,\r\n    vel_max_x,vel_max_y,vel_max_z,\r\n    t,T,T_s):\r\n    # acc_max_x, acc_max_y, acc_max_z = get_acc_max()\r\n    # vel_max_x, vel_max_y, vel_max_z = get_vel_max()\r\n    \r\n    if t < T_s:\r\n        x_des_pos = x_pos + 0.5 * acc_max_x * t**2\r\n        y_des_pos = y_pos + 0.5 * acc_max_y * t**2\r\n        z_des_pos = z_pos + 0.5 * acc_max_z * t**2\r\n    elif T_s < t <= T-T_s:\r\n        x_des_pos = x_pos + vel_max_x * t\r\n        y_des_pos = y_pos + vel_max_y * t\r\n        z_des_pos = z_pos + vel_max_z * t\r\n    elif t > T-T_s :\r\n        x_des_pos = x_pos + 0.5 * (-acc_max_x) * t**2\r\n        y_des_pos = y_pos + 0.5 * (-acc_max_y) * t**2\r\n        z_des_pos = z_pos + 0.5 * (-acc_max_z) * t**2\r\n    \r\n    return x_des_pos, y_des_pos, z_des_pos\r\n\r\ndef bang_velocity(acc_max_x,acc_max_y,acc_max_z,\r\n    vel_max_x,vel_max_y,vel_max_z,\r\n    t,T,T_s):\r\n    # acc_max_x, acc_max_y, acc_max_z = get_acc_max()\r\n    # vel_max_x, vel_max_y, vel_max_z = get_vel_max()\r\n    \r\n    if t < T_s:\r\n        x_des_vel = acc_max_x * t\r\n        y_des_vel = acc_max_y * t\r\n        z_des_vel = acc_max_z * t\r\n    elif T_s < t <= T-T_s:\r\n        x_des_vel = vel_max_x \r\n        y_des_vel = vel_max_y \r\n        z_des_vel = vel_max_z \r\n    elif t > T-T_s :\r\n        x_des_vel = -acc_max_x * t\r\n        y_des_vel = -acc_max_y * t\r\n        z_des_vel = -acc_max_z * t\r\n\r\n    \r\n    return x_des_vel, y_des_vel, z_des_vel\r\n\r\ndef bang_accelleration(acc_max_x,acc_max_y,acc_max_z,\r\n    t,T,T_s):\r\n    if t < T_s:\r\n        x_des_acc = acc_max_x\r\n        y_des_acc = acc_max_y\r\n        z_des_acc = acc_max_z\r\n    elif T_s < t <= T-T_s:\r\n        x_des_acc = 0 \r\n        y_des_acc = 0 \r\n        z_des_acc = 0 \r\n    elif t > T-T_s :\r\n        x_des_acc = -acc_max_x \r\n        y_des_acc = -acc_max_y \r\n        z_des_acc = -acc_max_z \r\n\r\n    return x_des_acc, y_des_acc, z_des_acc\r\n\r\n\r\ndef bang_position_2D(x_pos,y_pos,\r\n    acc_max_x,acc_max_y,t,T,T_s, goal_x, goal_y):\r\n    \r\n    if t <= T_s:\r\n        x_des_pos = x_pos + 0.5 * acc_max_x * t**2\r\n        y_des_pos = y_pos + 0.5 * acc_max_y * t**2\r\n    elif T_s < t <= T-T_s:\r\n        x_des_pos = x_pos + 0.5 * acc_max_x * T_s * (t - 0.5 * T_s)\r\n        y_des_pos = y_pos + 0.5 * acc_max_y * T_s * (t - 0.5 * T_s)\r\n    elif t > T-T_s:\r\n        x_des_pos = goal_x + 0.5 * (-acc_max_x) * (T-t)**2\r\n        y_des_pos = goal_y + 0.5 * (-acc_max_y) * (T-t)**2\r\n    \r\n    return x_des_pos, y_des_pos\r\n\r\ndef bang_velocity_2D(acc_max_x,acc_max_y,t,T,T_s):\r\n    # acc_max_x, acc_max_y, acc_max_z = get_acc_max()\r\n    # vel_max_x, vel_max_y, vel_max_z = get_vel_max()\r\n    \r\n    if t < T_s:\r\n        x_des_vel = acc_max_x * t\r\n        y_des_vel = acc_max_y * t\r\n    elif T_s < t <= T-T_s:\r\n        x_des_vel = T_s * acc_max_x\r\n        y_des_vel = T_s * acc_max_y\r\n    elif t > T-T_s:\r\n        x_des_vel = acc_max_x * (T - t)\r\n        y_des_vel = acc_max_y * (T - t)\r\n    \r\n    return x_des_vel, y_des_vel\r\n\r\ndef bang_accelleration_2D(acc_max_x,acc_max_y,\r\n    t,T,T_s):\r\n    if t < T_s:\r\n        x_des_acc = acc_max_x\r\n        y_des_acc = acc_max_y\r\n    elif T_s < t <= T-T_s:\r\n        x_des_acc = 0 \r\n        y_des_acc = 0 \r\n    elif t > T-T_s :\r\n        x_des_acc = -acc_max_x \r\n        y_des_acc = -acc_max_y \r\n\r\n    return x_des_acc, y_des_acc\r\n\r\n\r\n\r\n\r\ndef get_3D_components(start3D,end3D,scalar):\r\n    d_x = end3D[0] - start3D[0] \r\n    d_y = end3D[1] - start3D[1] \r\n    d_z = end3D[2] - start3D[2] \r\n    d = distance_3D(start3D, end3D)\r\n\r\n    alpha = math.acos(d_x/d)\r\n    beta = math.acos(d_y/d)\r\n    gamma = math.acos(d_z/d)\r\n\r\n    x_component = math.cos(alpha) * scalar\r\n    y_component = math.cos(beta) * scalar\r\n    z_component = math.cos(gamma) * scalar\r\n\r\n    return x_component, y_component, z_component\r\n    \r\n\r\ndef get_2D_components(start2D,end2D,scalar):\r\n    d_x = end2D[0] - start2D[0] \r\n    d_y = end2D[1] - start2D[1] \r\n    d = distance_2D(start2D, end2D)\r\n    \r\n    angle = math.acos(d_x/d)\r\n    \r\n    x_component = math.cos(angle) * scalar\r\n    y_component = math.sin(angle) * scalar\r\n\r\n    return x_component, y_component\r\n    \r\n\r\ndef distance_2D(start,end):\r\n    return math.sqrt( (end[1] - start[1] ) **2 + (end[0] - start[0] )**2 )    \r\n\r\ndef distance_3D(start,end):\r\n    return math.sqrt( (end[2] - start[2] )**2 + (end[1] - start[1] ) **2 + (end[0] - start[0] )**2 )    \r\n\r\n# -------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\ndef main():\r\n    \"\"\"\r\n    Print info header in the log\r\n    \"\"\"\r\n    sys.stdout = Logger()\r\n    print(\"\\n\\n\\n\" + \"\".join([\"#\"] * 50))\r\n    if sys.platform.startswith('linux'):\r\n        print(\"User:\", format(getenv(\"USER\")))  # For Linux\r\n    if sys.platform.startswith('win32'):\r\n        print(\"User:\", format(getenv(\"USERNAME\")))  # For Windows\r\n    print(\"OS:\", sys.platform)\r\n    print(\"Date:\", format(datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]))\r\n    print(\"\".join([\"#\"] * 50) + \"\\n\\n\\n\")\r\n    \"\"\"\r\n    Calculates the x, y, z coefficients for the four segments \r\n    of the trajectory\r\n    \"\"\"\r\n    x_coeffs = [[], [], [], []]\r\n    y_coeffs = [[], [], [], []]\r\n    z_coeffs = [[], [], [], []]\r\n    \r\n    for i in range(num_waypoints):\r\n        L = distance_2D(waypoints[i],waypoints[(i+1)%num_waypoints])\r\n        T = (L*acc_max_scalar + vel_max_scalar **2 ) /(acc_max_scalar * vel_max_scalar)\r\n        print(\"L:\",L,\", T:\",T)\r\n\r\n        traj = TrajectoryGenerator(waypoints[i], waypoints[(i + 1) % num_waypoints], T)\r\n        traj.solve()\r\n        x_coeffs[i] = traj.x_c\r\n        y_coeffs[i] = traj.y_c\r\n        z_coeffs[i] = traj.z_c\r\n\r\n\r\n    quad_sim(x_coeffs, y_coeffs, z_coeffs)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- custom_gym/Transition_model/drone_3d_trajectory_following.py	(revision 59582719fefe653bf588dd47df0613c86fc05833)
+++ custom_gym/Transition_model/drone_3d_trajectory_following.py	(date 1600955966039)
@@ -16,7 +16,7 @@
 from simple_pid import PID
 import matplotlib
 import matplotlib.pyplot as plt
-matplotlib.use("Qt5agg")
+#matplotlib.use("Qt5agg")
 from matplotlib.animation import FuncAnimation
 from Pid_plotter import PIDPlotter
 show_animation = False

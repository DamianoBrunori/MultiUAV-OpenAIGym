# MAIN VARIABLES DEFINITION. 

from math import ceil
import numpy as np

# OBSERVATION
N_UC = 2
N_CS = 1
N_TIMESLOTS_PER_HOUR = 60
N_TIMESLOTS_PER_DAY = N_TIMESLOTS_PER_HOUR*24 
N_BATTERY_LEVELS = 10
N_UAVS = 1
PROPULSION_BATTERY_CONSUMPTION = 3.33
HOVERING_ENERGY_CONSUMPTION = 2
EDGE_COMPUTING_ENERGY_CONSUMPTION = 1

UAVS_POS = [(4,4,2), (2,4,6)]

UAV_FOOTPRINT = 3

TR_BATTERY_CONSUMPTION = 1
EC_BATTERY_CONSUMPTION = 1

# TRAINING PARAMETERS
EPISODES = 500 # epochs
ITERATIONS_PER_EPISODE = 30
STEPS = N_TIMESLOTS_PER_DAY

R_MAX = False
PRIOR_KNOWLEDGE = False
X_SPLIT = 2
Y_SPLIT = 3
N_SUBAREAS = X_SPLIT*Y_SPLIT
#USERS_SERVED_TIME = 0
#USERS_REQUEST_SERVICE_ELAPSED_TIME = 0

# AREA DIMENSIONS:
AREA_WIDTH = 10
AREA_HEIGHT = 10
LOWER_BOUNDS = 0
CELL_RESOLUTION_PER_ROW = 1
CELL_RESOLUTION_PER_COL = 1
CELLS_ROWS = int(AREA_HEIGHT/CELL_RESOLUTION_PER_ROW)
CELLS_COLS = int(AREA_WIDTH/CELL_RESOLUTION_PER_COL)
N_CELLS = CELLS_ROWS*CELLS_COLS
MINIMUM_AREA_HEIGHT = 0
MAXIMUM_AREA_HEIGHT = 12
MAX_HEIGHT_PER_USER = 3
MIN_UAV_HEIGHT = 4
MAX_UAV_HEIGHT = MAXIMUM_AREA_HEIGHT

# CAMBIA IL CONSUMO DEGLI UAV NEL CASO IN CUI UTILIZZO UNA RISOLUZIONE DIVERSA DA QUELLA MINIMA --> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
HALF_RESOLUTION_X =(AREA_WIDTH//CELLS_COLS)/2
HALF_RESOLUTION_Y =(AREA_WIDTH//CELLS_ROWS)/2
HALF_RESOLUTION_Z = 0.5 # --> the resolution along z is fixed
UAV_XY_STEP = 1
UAV_Z_STEP = 3

CREATE_ENODEB = False
DIMENSION_2D = False
UNLIMITED_BATTERY = True
INF_REQUEST = True

CONSUMPTION_PER_ITERATION = 1

# OBSTACLES PARAMETERS:
MIN_OBS_PER_AREA = 0.05
MAX_OBS_PER_AREA = 0.15
MIN_OBS_HEIGHT = 3
MAX_OBS_HEIGHT = 7

# CHARGING STATION PARAMETERS:
CS_HEIGHT = MIN_UAV_HEIGHT
# Setting RADIAL_DISTANCE_X equal to RADIAL_DISTANCE_Y, CSs will be set at an equal distance w.r.t. the eNB (eNodeB) position;
# Obviously the values of RADIAL_DISTANCE_X and RADIAL_DISTANCE_Y must not exceed the distance between the eNodeB and the area dimensions.
RADIAL_DISTANCE_X = 4
RADIAL_DISTANCE_Y = 4

# ENODEB POSITION:
ENODEB_X = ceil(AREA_WIDTH/2) 
ENODEB_Y = ceil(AREA_HEIGHT/2)
ENODEB_Z = 6

# CELLS STATES:
FREE = 0
OBS_IN = 1
CS_IN = 2
ENB_IN = 3
UAV_IN = 4

NEEDED_SERVICE_TIMES_PER_USER = [1, 2, 3, 4] 


# AGENT STATES:
FULL_BATTERY_LEVEL = 100
CRITICAL_BATTERY_LEVEL = 15
UC_DISTANCES = 2 # Distances of the uncovered clusters of users 
CS_DISTANCE = 1 # Distance of the nearest Charging Station
PROCESSED_DATA = 4 
# Tuple Agent State --> (BATTERY_LEVEL, UC_DISTANCES, CS_DISTANCE, PROCESSED_DATA)

# ACTUAL AGENT STATE:
# (CELL_STATE, AGENT_STATE)

# AGENT PARAMETERS:
MAX_SPEED = 8.3 # [m/s]
MAX_ACCELERATION = 4 # [m/s^2]
HOVERING_TIME = 60 # [s]
BATTERY_AUTONOMY_TIME = 1800 # [s]
MINIMUM_CHARGING_TIME = 300 # [s]
MAX_BW_PER_UAV = 5 # [MHz]

# ACTIONS:
MOVE = 0
HOVERING = 4
UP = 5
DOWN = 6
LEFT = 7
RIGHT = 8
RISE = 9
DROP = 10
MOVEMENTS = [UP, DOWN, LEFT, RIGHT, RISE, DROP]
COVER = 1
CHARGE = 2
PROCESS_DATA = 3
NOT_ALLOWED_MOTION = -1

ACTION_SPACE_3D = [UP, DOWN, LEFT, RIGHT, RISE, DROP, HOVERING] # TO DEFINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DICT_ACTION_SPACE_3D = {ACTION_SPACE_3D.index(UP): "UP", ACTION_SPACE_3D.index(DOWN): "DOWN", ACTION_SPACE_3D.index(LEFT): "LEFT", ACTION_SPACE_3D.index(RIGHT): "RIGHT", ACTION_SPACE_3D.index(RISE): "RISE", ACTION_SPACE_3D.index(DROP): "DROP", ACTION_SPACE_3D.index(HOVERING): "HOVER"}
ACTION_SPACE_2D = [UP, DOWN, LEFT, RIGHT, HOVERING]
DICT_ACTION_SPACE_2D = {ACTION_SPACE_2D.index(UP): "UP", ACTION_SPACE_2D.index(DOWN): "DOWN", ACTION_SPACE_2D.index(LEFT): "LEFT", ACTION_SPACE_2D.index(RIGHT): "RIGHT", ACTION_SPACE_2D.index(HOVERING): "HOVER"}
DICT_ACTION_SPACE = DICT_ACTION_SPACE_2D if DIMENSION_2D == True else DICT_ACTION_SPACE_3D
LIMIT_VALUES_FOR_ACTION = [] # --> sar√† una lista di tuple (min_val, max_val)

# ENVIRONMENT PARAMETERS:
BS_POS = np.vstack((ENODEB_X, ENODEB_Y, ENODEB_Z))
AVG_BUILDS_HEIGHT = 4
AVG_ROAD_WIDTH = 20
AVG_BUILDS_SEPARATION = 36
PHI = 10 # Slope roads angle
OPERATING_FREQUENCY = 2.1
BS_BANDWIDTH = 40 # [MHz]
UAV_BANDWIDTH = 5 # [MHz]

# MODULATION:
NoTx = 0
QPSK = 1
_16QAM = 2
_64QAM = 3

# LOOKUP TABLE:
LOOKUP_TABLE = {'CQI_index': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 , 14, 15],
				'modulation': [NoTx, NoTx, NoTx, QPSK, QPSK, QPSK, _16QAM, _16QAM, _16QAM, _64QAM, _64QAM, _64QAM, _64QAM, _64QAM, _64QAM],
				'code_rate': [None, None, None, 0.3, 0.44, 0.59, 0.37, 0.48, 0.6, 0.45, 0.55, 0.65, 0.75, 0.85, 0.93],
				'bits_per_symbol': [None, None, None, 0.6016, 0.8770, 1.1758, 1.4766, 1.9141, 2.4063, 2.7305, 3.3223, 3.9023, 4.5234, 5.1152, 5.5547],
				'SINR_dB': [-1.25, -1.25, -1.25, -0.94, 1.09, 2.97, 5.31, 6.72, 8.75, 10.47, 12.34, 14,37, 15.94, 17.81, 20.31],
				'TBS': [0, 0, 0, 384, 576, 768, 960, 1152, 1536, 1920, 2304, 2688, 3072, 3456, 3840],
				'SE': [0.1065, 0.1640, 0.2638, 0.4211, 0.6139, 0.8222, 1.0333, 1.3389, 1.6833, 1.9111, 2.3222, 2.7278, 3.1611, 3.5778, 3.8833]
				}

# MIN AND MAX VALUES TO DETERMINE THE EVENTUAL MAX PEAK OF USER PER DAY:
MIN_USERS_PER_DAY = 15
MAX_USERS_PER_DAY = 30 

# MAX AND MIN PERCENTAGE NUMBER OF USERS PER TIMESLOT:
MIN_USERS_PERCENTAGE1 = 0.15 # Timeslot 1-4 A.M. 
MIN_USERS_PERCENTAGE2 = 0.30 # Timeslot 4-8 A.M.
MIN_USERS_PERCENTAGE3 = 0.40 # Timeslot 8-12 A.M.
MIN_USERS_PERCENTAGE4 = 0.50 # Timeslot 1-4 P.M.
MIN_USERS_PERCENTAGE5 = 0.80 # Timeslot 4-8 P.M.
MIN_USERS_PERCENTAGE6 = 0.30 # Timeslot 8-12 P.M.

MAX_USERS_PERCENTAGE1 = 0.25 # Timeslot 1-4 A.M.
MAX_USERS_PERCENTAGE2 = 0.40 # Timeslot 4-8 A.M.
MAX_USERS_PERCENTAGE3 = 0.50 # Timeslot 8-12 A.M.
MAX_USERS_PERCENTAGE4 = 0.70 # Timeslot 1-4 P.M.
MAX_USERS_PERCENTAGE5 = 1.0 # Timeslot 4-8 P.M.
MAX_USERS_PERCENTAGE6 = 0.45 # Timeslot 8-12 P.M.

MIN_MAX_USERS_PERCENTAGES = [(MIN_USERS_PERCENTAGE1, MAX_USERS_PERCENTAGE1), (MIN_USERS_PERCENTAGE2, MAX_USERS_PERCENTAGE2), \
							 (MIN_USERS_PERCENTAGE3, MAX_USERS_PERCENTAGE3), (MIN_USERS_PERCENTAGE4, MAX_USERS_PERCENTAGE4), \
							 (MIN_USERS_PERCENTAGE5, MAX_USERS_PERCENTAGE5), (MIN_USERS_PERCENTAGE6, MAX_USERS_PERCENTAGE6)]

MACRO_TIME_SLOTS = 6
HOURS_PER_CONSIDERED_TIME = 24
MICRO_SLOTS_PER_MACRO_TIMESLOT = HOURS_PER_CONSIDERED_TIME//MACRO_TIME_SLOTS
STARTING_TIMESLOT = MICRO_SLOTS_PER_MACRO_TIMESLOT 
HOURS_VALID_UPPER_BOUND = HOURS_PER_CONSIDERED_TIME+1

# USERS BITRATE REQUESTS [Kb/s]:
AUDIO_STREAM_NORMAL = 96
AUDIO_STREAM_HIGH = 160
AUDIO_STREAM_EXTREME = 320
VIDEOCALL = 200
YOUTUBE_360p = 750
YOUTUBE_480p = 1000
YOUTUBE_720p = 2500
TRHOUGHPUT_REQUESTS = [AUDIO_STREAM_NORMAL, VIDEOCALL, AUDIO_STREAM_HIGH, YOUTUBE_360p, AUDIO_STREAM_EXTREME, YOUTUBE_480p, YOUTUBE_720p]

TR_SERVICE_TIME1 = 1
TR_SERVICE_TIME2 = 2
TR_SERVICE_TIME3 = 3
TR_SERVICE_TIME4 = 4
TR_SERVICE_TIME5 = 5
TR_SERVICE_TIME6 = 6
TR_SERVICE_TIMES = [TR_SERVICE_TIME1, TR_SERVICE_TIME2, TR_SERVICE_TIME3, TR_SERVICE_TIME4, TR_SERVICE_TIME5, TR_SERVICE_TIME6]

# USERS BYTE REQUEST FOR EDGE-COMPUTING:
BYTE1 = 10
BYTE2 = 20
BYTE3 = 30
BYTE4 = 40
BYTE5 = 50
EDGE_COMPUTING_REQUESTS = [BYTE1, BYTE2, BYTE3, BYTE4, BYTE5]

EC_SERVICE_TIME = 1

# USERS MESSAGES FOR DATA GATHERING:
MESSAGE1 = 3
MESSAGE2 = 6
MESSAGE3 = 9
MESSAGE4 = 12
MESSAGE5 = 24
DATA_GATHERING_REQUESTS = [MESSAGE1, MESSAGE2, MESSAGE3, MESSAGE4, MESSAGE5]

DG_SERVICE_TIME = 1

# POSSIBLE SERVICES:
NO_SERVICE = 0
THROUGHPUT_REQUEST = 0
EDGE_COMPUTING = 1
DATA_GATHERING = 2
UAVS_SERVICES = [THROUGHPUT_REQUEST, EDGE_COMPUTING, DATA_GATHERING]

FIXED_CLUSTERS_NUM = 1
# LIST OF THE NUMBER OF CLUSTERS TO TEST WHEN LOOKING FOR THE OPTIMAL NUMBER OF USERS CLUSTERS:
CLUSTERS_NUM_TO_TEST = [3, 4, 5, 6, 7, 8, 9, 10]

# USER PARAMETERS:
FREE_USER = 0
BASE_USER = 1
FULL_USER = 2
PREMIUM_USER = 3
USERS_ACCOUNTS_DITRIBUTIONS = [0.4, 0.3, 0.2, 0.1]

# COLORS FOR PLOTTING:
WHITE = "#ffffff"
LIGHT_RED = "#ff0000"
DARK_RED = "#800000"
LIGHT_BLUE = "#66ffff"
DARK_BLUE = "#000099"
LIGHT_GREEN = "#66ff99"
DARK_GREEN = "#006600"
PURPLE = "#cf03fc"
ORANGE = "#fc8c03"
BROWN = "#8b4513"
GOLD = '#FFD700'
HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'] # Used to generate random hex color related to the users clusters.
HEX_COLOR_CODE = '#'

# DIRECTORIES:
MAP_DATA_DIR = "./map_data/"
MAP_STATUS_DIR = "./map_status/"
INITIAL_USERS_DIR = "./initial_users/"
AGENTS_DIR = "./scenario_agents"

# FILES:
OBS_POINTS_LIST = "obs_points.npy"
POINTS_MATRIX = "points_matrix.npy"
CS_POINTS = "cs_points.npy"
ENODEB_POINT = "eNB_point.npy"

CELLS_MATRIX = "cells_matrix.npy"
OBS_CELLS = "obs_cells.npy"
CS_CELLS = "cs_cells.npy"
ENB_CELLS = "enb_cells.npy"

POINTS_STATUS_MATRIX = "points_status_matrix.npy"
CELLS_STATUS_MATRIX = "cells_status_matrix.npy"
PERCEIVED_STATUS_MATRIX = "perceived_status_matrix.npy"

INITIAL_USERS = "initial_users.npy"
INITIAL_CENTROIDS = "initial_centroids.npy"
INITIAL_CLUSTERS_RADIUSES = "initial_clusters_radiuses.npy"
INITIAL_CLUSTERER = "initial_clusterer.npy"

AGENTS = "agents.npy"
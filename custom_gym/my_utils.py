# MAIN VARIABLES DEFINITION.

from math import ceil, pi, sin, cos
import numpy as np

def hex_to_rgb(hex):
     hex = hex.lstrip('#')
     hlen = len(hex)
     rgb = tuple(int(hex[i:i+hlen//3], 16) for i in range(0, hlen, hlen//3))
     rgb_percentage = [color_part/255 for color_part in rgb]
     return tuple(rgb_percentage)

N_TIMESLOTS_PER_HOUR = 60
N_TIMESLOTS_PER_DAY = N_TIMESLOTS_PER_HOUR*24

# TRAINING PARAMETERS
EPISODES = 5 # epochs
ITERATIONS_PER_EPISODE = 30
STEPS = N_TIMESLOTS_PER_DAY

#FULL_BATTERY_LEVEL = 100
#BATTERY_LEVEL_CONSIDERED_FULL = FULL_BATTERY_LEVEL-1

# OBSERVATION
N_UC = 2
N_CS = 2
N_BATTERY_LEVELS = 10
PERC_CONSUMPTION_PER_ITERATION = 4 # --> in this way it is possible to have integer battery levels withouth approximation errors which lead to 'Key Error' ininside Q-table dictionary
FULL_BATTERY_LEVEL = ITERATIONS_PER_EPISODE*PERC_CONSUMPTION_PER_ITERATION # = iteration * 4
PERC_BATTERY_CHARGED_PER_IT = 20
BATTERY_CHARGED_PER_IT = round((PERC_BATTERY_CHARGED_PER_IT*FULL_BATTERY_LEVEL)/100)
#PERC_CONSUMPTION_PER_ITERATION = STEP_REDUCTION_TO_GO_TO_CS
PERC_BATTERY_TO_GO_TO_CS = int(PERC_CONSUMPTION_PER_ITERATION/4) # --> 4/4 = 1
N_UAVS = 2
PROPULSION_BATTERY_CONSUMPTION = 3.33
HOVERING_ENERGY_CONSUMPTION = 2
EDGE_COMPUTING_ENERGY_CONSUMPTION = 1

PERC_CRITICAL_BATTERY_LEVEL = 20
CRITICAL_BATTERY_LEVEL = round((PERC_CRITICAL_BATTERY_LEVEL*FULL_BATTERY_LEVEL)/100)
CRITICAL_BATTERY_LEVEL_2 = round(CRITICAL_BATTERY_LEVEL/1.5)
CRITICAL_BATTERY_LEVEL_3 = round(CRITICAL_BATTERY_LEVEL_2/1.5)
CRITICAL_BATTERY_LEVEL_4 = round(CRITICAL_BATTERY_LEVEL_3/1.5)
PERC_MINIMUM_BATTERY_LEVEL_TO_STOP_CHARGING = 80
MINIMUM_BATTERY_LEVEL_TO_STOP_CHARGING = round((PERC_MINIMUM_BATTERY_LEVEL_TO_STOP_CHARGING*FULL_BATTERY_LEVEL)/100)

SHOW_BATTERY_LEVEL_FOR_CHARGING_INSTANT = 400

# AREA DIMENSIONS:
AREA_WIDTH = 10
AREA_HEIGHT = 10
LOWER_BOUNDS = 0
CELL_RESOLUTION_PER_ROW = 1
CELL_RESOLUTION_PER_COL = 1
CELLS_ROWS = int(AREA_HEIGHT/CELL_RESOLUTION_PER_ROW)
CELLS_COLS = int(AREA_WIDTH/CELL_RESOLUTION_PER_COL)
N_CELLS = CELLS_ROWS*CELLS_COLS
MINIMUM_AREA_HEIGHT = 0
MAXIMUM_AREA_HEIGHT = 12
MAX_HEIGHT_PER_USER = 3
MIN_UAV_HEIGHT = 4

# Setting RADIAL_DISTANCE_X equal to RADIAL_DISTANCE_Y, CSs will be set at an equal distance w.r.t. the eNB (eNodeB) position;
# Obviously the values of RADIAL_DISTANCE_X and RADIAL_DISTANCE_Y must not exceed the distance between the eNodeB and the area dimensions.
RADIAL_DISTANCE_X = 4
RADIAL_DISTANCE_Y = 4

CREATE_ENODEB = False
DIMENSION_2D = True
UNLIMITED_BATTERY = True
INF_REQUEST = True
STATIC_REQUEST = True
USERS_PRIORITY = False

RAD_BETWEEN_POINTS = 2*pi/N_UAVS
UAVS_POS = []
for uav_idx in range(N_UAVS):
    if (DIMENSION_2D == True):
        UAVS_POS.append((round(ceil(CELLS_COLS / 2) + RADIAL_DISTANCE_X * sin(uav_idx * RAD_BETWEEN_POINTS)),
                         round(ceil(CELLS_ROWS / 2) + RADIAL_DISTANCE_Y * cos(uav_idx * RAD_BETWEEN_POINTS)), 0))
    else:
        UAVS_POS.append((round(ceil(CELLS_COLS / 2) + RADIAL_DISTANCE_X * sin(uav_idx * RAD_BETWEEN_POINTS)),
                         round(ceil(CELLS_ROWS / 2) + RADIAL_DISTANCE_Y * cos(uav_idx * RAD_BETWEEN_POINTS)),
                         MIN_UAV_HEIGHT))
# UAVS_POS_2D = [(4,4), (2,4)]

TR_BATTERY_CONSUMPTION = 1
EC_BATTERY_CONSUMPTION = 2

R_MAX = False
PRIOR_KNOWLEDGE = False
X_SPLIT = 2
Y_SPLIT = 3
N_SUBAREAS = X_SPLIT*Y_SPLIT
#USERS_SERVED_TIME = 0
#USERS_REQUEST_SERVICE_ELAPSED_TIME = 0

TIME_SLOT_FOr_DELAYED_START = 5
DELAYED_START_PER_UAV = ITERATIONS_PER_EPISODE/TIME_SLOT_FOr_DELAYED_START # 30/5 = 6
UAV_FOOTPRINT = 2.5
ACTUAL_UAV_FOOTPRINT = UAV_FOOTPRINT/CELL_RESOLUTION_PER_COL

# CAMBIA IL CONSUMO DEGLI UAV NEL CASO IN CUI UTILIZZO UNA RISOLUZIONE DIVERSA DA QUELLA MINIMA --> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
HALF_RESOLUTION_X =(AREA_WIDTH//CELLS_COLS)/2
HALF_RESOLUTION_Y =(AREA_WIDTH//CELLS_ROWS)/2
HALF_RESOLUTION_Z = 0.5 # --> the resolution along z is fixed
UAV_XY_STEP = 0.6 #Range > 0.1
UAV_Z_STEP = 0.5  #Range (Min 0.5)
APPROXIMATE = 2   #Numero di cifre dopo la virgola (Approssimazione)

# OBSTACLES PARAMETERS:
MIN_OBS_PER_AREA = 0.05
MAX_OBS_PER_AREA = 0.15
MIN_OBS_HEIGHT = 3
MAX_OBS_HEIGHT = MAXIMUM_AREA_HEIGHT

# CHARGING STATION PARAMETERS:
CS_HEIGHT = MIN_UAV_HEIGHT

# ENODEB POSITION:
ENODEB_X = ceil(AREA_WIDTH/2)
ENODEB_Y = ceil(AREA_HEIGHT/2)
ENODEB_Z = 6

# CELLS STATES:
FREE = 0
OBS_IN = 1
CS_IN = 2
ENB_IN = 3
UAV_IN = 4

NEEDED_SERVICE_TIMES_PER_USER = [1, 2, 3, 4]


# AGENT STATES:
UC_DISTANCES = 2 # Distances of the uncovered clusters of users
CS_DISTANCE = 1 # Distance of the nearest Charging Station
PROCESSED_DATA = 4
# Tuple Agent State --> (BATTERY_LEVEL, UC_DISTANCES, CS_DISTANCE, PROCESSED_DATA)

# ACTUAL AGENT STATE:
# (CELL_STATE, AGENT_STATE)

# AGENT PARAMETERS:
MAX_SPEED = 8.3 # [m/s]
MAX_ACCELERATION = 4 # [m/s^2]
HOVERING_TIME = 60 # [s]
BATTERY_AUTONOMY_TIME = 1800 # [s]
MINIMUM_CHARGING_TIME = 300 # [s]
MAX_BW_PER_UAV = 5 # [MHz]

# ACTIONS:
MOVE = 0
HOVERING = 4
UP = 5
DOWN = 6
LEFT = 7
RIGHT = 8
UPLEFT = 11
UPRIGHT = 12
DOWNLEFT = 13
DOWNRIGHT = 14
RISE = 9
DROP = 10
MOVEMENTS = [UP, DOWN, LEFT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, RIGHT, RISE, DROP]
GO_TO_CS = 1
CHARGE = 2
PROCESS_DATA = 3
NOT_ALLOWED_MOTION = -1


ACTION_SPACE_3D_MIN = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, RISE, DROP, HOVERING] # TO DEFINE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ACTION_SPACE_3D_COME_HOME = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, RISE, DROP, HOVERING, GO_TO_CS]
ACTION_SPACE_3D_WHILE_CHARGING = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, RISE, DROP, HOVERING, CHARGE]
ACTION_SPACE_3D_TOTAL = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, RISE, DROP, HOVERING, GO_TO_CS, CHARGE]
GO_TO_CS_3D_INDEX = ACTION_SPACE_3D_TOTAL.index(GO_TO_CS)
GO_TO_CS_3D_INDEX_HOME_SPACE = ACTION_SPACE_3D_COME_HOME.index(GO_TO_CS)
CHARGE_3D_INDEX = ACTION_SPACE_3D_TOTAL.index(CHARGE)
CHARGE_3D_INDEX_WHILE_CHARGING = ACTION_SPACE_3D_WHILE_CHARGING.index(CHARGE)

ACTION_SPACE_2D_MIN = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, HOVERING]
ACTION_SPACE_2D_COME_HOME = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, HOVERING, GO_TO_CS]
ACTION_SPACE_2D_WHILE_CHARGING = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, HOVERING, CHARGE]
ACTION_SPACE_2D_TOTAL = [UP, DOWN, LEFT, RIGHT, UPLEFT, UPRIGHT, DOWNLEFT, DOWNRIGHT, HOVERING, GO_TO_CS, CHARGE]
GO_TO_CS_2D_INDEX = ACTION_SPACE_2D_TOTAL.index(GO_TO_CS)
GO_TO_CS_2D_INDEX_HOME_SPACE = ACTION_SPACE_2D_COME_HOME.index(GO_TO_CS)
CHARGE_2D_INDEX = ACTION_SPACE_2D_TOTAL.index(CHARGE)
CHARGE_2D_INDEX_WHILE_CHARGING = ACTION_SPACE_2D_WHILE_CHARGING.index(CHARGE)

if (DIMENSION_2D==True):
	if (UNLIMITED_BATTERY == True):
		DICT_ACTION_SPACE_2D = {ACTION_SPACE_2D_MIN.index(UP): "UP",
                                ACTION_SPACE_2D_MIN.index(DOWN): "DOWN",
                                ACTION_SPACE_2D_MIN.index(LEFT): "LEFT",
                                ACTION_SPACE_2D_MIN.index(RIGHT): "RIGHT",
                                ACTION_SPACE_2D_MIN.index(UPLEFT): "UPLEFT",
                                ACTION_SPACE_2D_MIN.index(UPRIGHT): "UPRIGHT",
                                ACTION_SPACE_2D_MIN.index(DOWNLEFT): "DOWNLEFT",
                                ACTION_SPACE_2D_MIN.index(DOWNRIGHT): "DOWNRIGHT",
                                ACTION_SPACE_2D_MIN.index(HOVERING): "HOVER"}
	else:
		DICT_ACTION_SPACE_2D = {ACTION_SPACE_2D_TOTAL.index(UP): "UP",
                                ACTION_SPACE_2D_TOTAL.index(DOWN): "DOWN",
                                ACTION_SPACE_2D_TOTAL.index(LEFT): "LEFT",
                                ACTION_SPACE_2D_TOTAL.index(RIGHT): "RIGHT",
                                ACTION_SPACE_2D_MIN.index(UPLEFT): "UPLEFT",
                                ACTION_SPACE_2D_MIN.index(UPRIGHT): "UPRIGHT",
                                ACTION_SPACE_2D_MIN.index(DOWNLEFT): "DOWNLEFT",
                                ACTION_SPACE_2D_MIN.index(DOWNRIGHT): "DOWNRIGHT",
                                ACTION_SPACE_2D_TOTAL.index(HOVERING): "HOVER",
                                ACTION_SPACE_2D_TOTAL.index(GO_TO_CS): "GO CS",
                                ACTION_SPACE_2D_TOTAL.index(CHARGE): "CHARGE"}
else:
	if (UNLIMITED_BATTERY == True):
		DICT_ACTION_SPACE_3D = {ACTION_SPACE_3D_MIN.index(UP): "UP", ACTION_SPACE_3D_MIN.index(DOWN): "DOWN",
                                ACTION_SPACE_3D_MIN.index(LEFT): "LEFT", ACTION_SPACE_3D_MIN.index(RIGHT): "RIGHT",
                                ACTION_SPACE_2D_MIN.index(UPLEFT): "UPLEFT", ACTION_SPACE_2D_MIN.index(UPRIGHT): "UPRIGHT",
                                ACTION_SPACE_2D_MIN.index(DOWNLEFT): "DOWNLEFT", ACTION_SPACE_2D_MIN.index(DOWNRIGHT): "DOWNRIGHT",
                                ACTION_SPACE_3D_MIN.index(RISE): "RISE", ACTION_SPACE_3D_MIN.index(DROP): "DROP",
                                ACTION_SPACE_3D_MIN.index(HOVERING): "HOVER"}
	else:
		DICT_ACTION_SPACE_3D = {ACTION_SPACE_3D_TOTAL.index(UP): "UP", ACTION_SPACE_3D_TOTAL.index(DOWN): "DOWN",
                                ACTION_SPACE_3D_TOTAL.index(LEFT): "LEFT", ACTION_SPACE_3D_TOTAL.index(RIGHT): "RIGHT",
                                ACTION_SPACE_2D_MIN.index(UPLEFT): "UPLEFT", ACTION_SPACE_2D_MIN.index(UPRIGHT): "UPRIGHT",
                                ACTION_SPACE_2D_MIN.index(DOWNLEFT): "DOWNLEFT", ACTION_SPACE_2D_MIN.index(DOWNRIGHT): "DOWNRIGHT",
                                ACTION_SPACE_3D_TOTAL.index(RISE): "RISE", ACTION_SPACE_3D_TOTAL.index(DROP): "DROP",
                                ACTION_SPACE_3D_TOTAL.index(HOVERING): "HOVER", ACTION_SPACE_3D_TOTAL.index(GO_TO_CS): "GO CS",
                                ACTION_SPACE_3D_TOTAL.index(CHARGE): "CHARGE"}

DICT_ACTION_SPACE = DICT_ACTION_SPACE_2D if DIMENSION_2D==True else DICT_ACTION_SPACE_3D
LIMIT_VALUES_FOR_ACTION = [] # --> sarÃ  una lista di tuple (min_val, max_val)

# ENVIRONMENT PARAMETERS:
BS_POS = np.vstack((ENODEB_X, ENODEB_Y, ENODEB_Z))
AVG_BUILDS_HEIGHT = 4
AVG_ROAD_WIDTH = 20
AVG_BUILDS_SEPARATION = 36
PHI = 10 # Slope roads angle
OPERATING_FREQUENCY = 2.1
BS_BANDWIDTH = 40 # [MHz]
UAV_BANDWIDTH = 5 # [MHz]

# MODULATION:
NoTx = 0
QPSK = 1
_16QAM = 2
_64QAM = 3

# LOOKUP TABLE:
LOOKUP_TABLE = {'CQI_index': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 , 14, 15],
				'modulation': [NoTx, NoTx, NoTx, QPSK, QPSK, QPSK, _16QAM, _16QAM, _16QAM, _64QAM, _64QAM, _64QAM, _64QAM, _64QAM, _64QAM],
				'code_rate': [None, None, None, 0.3, 0.44, 0.59, 0.37, 0.48, 0.6, 0.45, 0.55, 0.65, 0.75, 0.85, 0.93],
				'bits_per_symbol': [None, None, None, 0.6016, 0.8770, 1.1758, 1.4766, 1.9141, 2.4063, 2.7305, 3.3223, 3.9023, 4.5234, 5.1152, 5.5547],
				'SINR_dB': [-1.25, -1.25, -1.25, -0.94, 1.09, 2.97, 5.31, 6.72, 8.75, 10.47, 12.34, 14,37, 15.94, 17.81, 20.31],
				'TBS': [0, 0, 0, 384, 576, 768, 960, 1152, 1536, 1920, 2304, 2688, 3072, 3456, 3840],
				'SE': [0.1065, 0.1640, 0.2638, 0.4211, 0.6139, 0.8222, 1.0333, 1.3389, 1.6833, 1.9111, 2.3222, 2.7278, 3.1611, 3.5778, 3.8833]
				}

# MIN AND MAX VALUES TO DETERMINE THE EVENTUAL MAX PEAK OF USER PER DAY:
MIN_USERS_PER_DAY = 15
MAX_USERS_PER_DAY = 30

# MAX AND MIN PERCENTAGE NUMBER OF USERS PER TIMESLOT:
MIN_USERS_PERCENTAGE1 = 0.15 # Timeslot 1-4 A.M.
MIN_USERS_PERCENTAGE2 = 0.30 # Timeslot 4-8 A.M.
MIN_USERS_PERCENTAGE3 = 0.40 # Timeslot 8-12 A.M.
MIN_USERS_PERCENTAGE4 = 0.50 # Timeslot 1-4 P.M.
MIN_USERS_PERCENTAGE5 = 0.80 # Timeslot 4-8 P.M.
MIN_USERS_PERCENTAGE6 = 0.30 # Timeslot 8-12 P.M.

MAX_USERS_PERCENTAGE1 = 0.25 # Timeslot 1-4 A.M.
MAX_USERS_PERCENTAGE2 = 0.40 # Timeslot 4-8 A.M.
MAX_USERS_PERCENTAGE3 = 0.50 # Timeslot 8-12 A.M.
MAX_USERS_PERCENTAGE4 = 0.70 # Timeslot 1-4 P.M.
MAX_USERS_PERCENTAGE5 = 1.0 # Timeslot 4-8 P.M.
MAX_USERS_PERCENTAGE6 = 0.45 # Timeslot 8-12 P.M.

MIN_MAX_USERS_PERCENTAGES = [(MIN_USERS_PERCENTAGE1, MAX_USERS_PERCENTAGE1), (MIN_USERS_PERCENTAGE2, MAX_USERS_PERCENTAGE2), \
							 (MIN_USERS_PERCENTAGE3, MAX_USERS_PERCENTAGE3), (MIN_USERS_PERCENTAGE4, MAX_USERS_PERCENTAGE4), \
							 (MIN_USERS_PERCENTAGE5, MAX_USERS_PERCENTAGE5), (MIN_USERS_PERCENTAGE6, MAX_USERS_PERCENTAGE6)]

MACRO_TIME_SLOTS = 6
HOURS_PER_CONSIDERED_TIME = 24
MICRO_SLOTS_PER_MACRO_TIMESLOT = HOURS_PER_CONSIDERED_TIME//MACRO_TIME_SLOTS
STARTING_TIMESLOT = MICRO_SLOTS_PER_MACRO_TIMESLOT
HOURS_VALID_UPPER_BOUND = HOURS_PER_CONSIDERED_TIME+1

# USERS BITRATE REQUESTS [Kb/s]:
AUDIO_STREAM_NORMAL = 96
AUDIO_STREAM_HIGH = 160
AUDIO_STREAM_EXTREME = 320
VIDEOCALL = 200
YOUTUBE_360p = 750
YOUTUBE_480p = 1000
YOUTUBE_720p = 2500
TRHOUGHPUT_REQUESTS = [AUDIO_STREAM_NORMAL, VIDEOCALL, AUDIO_STREAM_HIGH, YOUTUBE_360p, AUDIO_STREAM_EXTREME, YOUTUBE_480p, YOUTUBE_720p]

TR_SERVICE_TIME1 = 1
TR_SERVICE_TIME2 = 2
TR_SERVICE_TIME3 = 3
TR_SERVICE_TIME4 = 4
TR_SERVICE_TIME5 = 5
TR_SERVICE_TIME6 = 6
TR_SERVICE_TIMES = [TR_SERVICE_TIME1, TR_SERVICE_TIME2, TR_SERVICE_TIME3, TR_SERVICE_TIME4, TR_SERVICE_TIME5, TR_SERVICE_TIME6]

# USERS BYTE REQUEST FOR EDGE-COMPUTING:
BYTE1 = 10
BYTE2 = 20
BYTE3 = 30
BYTE4 = 40
BYTE5 = 50
EDGE_COMPUTING_REQUESTS = [BYTE1, BYTE2, BYTE3, BYTE4, BYTE5]

EC_SERVICE_TIME = 1

# USERS MESSAGES FOR DATA GATHERING:
MESSAGE1 = 3
MESSAGE2 = 6
MESSAGE3 = 9
MESSAGE4 = 12
MESSAGE5 = 24
DATA_GATHERING_REQUESTS = [MESSAGE1, MESSAGE2, MESSAGE3, MESSAGE4, MESSAGE5]

DG_SERVICE_TIME = 1

# POSSIBLE SERVICES:
NO_SERVICE = 0
THROUGHPUT_REQUEST = 0
EDGE_COMPUTING = 1
DATA_GATHERING = 2
UAVS_SERVICES = [THROUGHPUT_REQUEST, EDGE_COMPUTING, DATA_GATHERING]

CENTROIDS_MIN_MAX_COORDS = [[(2,2), (5, 5)], [(7, 7), (7,7)]] # --> [(min_x, max_x), (min_y, max_y)]
#CENTROIDS_MIN_MAX_COORDS = [[(2,2), (5, 5)]]
FIXED_CLUSTERS_NUM = len(CENTROIDS_MIN_MAX_COORDS)
# LIST OF THE NUMBER OF CLUSTERS TO TEST WHEN LOOKING FOR THE OPTIMAL NUMBER OF USERS CLUSTERS:
CLUSTERS_NUM_TO_TEST = [3, 4, 5, 6, 7, 8, 9, 10]

# USER PARAMETERS:
BASE_USER = 1
FREE_USER = 0
FULL_USER = 2
PREMIUM_USER = 3
USERS_ACCOUNTS = [FREE_USER, BASE_USER, FULL_USER, PREMIUM_USER]
USERS_ACCOUNTS_DITRIBUTIONS = [0.4, 0.3, 0.2, 0.1]

# COLORS FOR PLOTTING:
WHITE = "#ffffff"
LIGHT_RED = "#ff0000"
DARK_RED = "#800000"
LIGHT_BLUE = "#66ffff"
DARK_BLUE = "#000099"
LIGHT_GREEN = "#66ff99"
DARK_GREEN = "#006600"
PURPLE = "#cf03fc"
ORANGE = "#fc8c03"
BROWN = "#8b4513"
GOLD = '#FFD700'
HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'] # Used to generate random hex color related to the users clusters.
HEX_COLOR_CODE = '#'
# UAVS colors:
VIOLET = '#EE82EE'
ORANGE = '#FFA500'
GREY = '#808080'
BROWN = '#A52A2A'
UAVS_COLORS = [VIOLET, ORANGE, GREY, BROWN]
UAVS_COLORS_RGB_PERCENTAGE = [hex_to_rgb(color) for color in UAVS_COLORS]

# DIRECTORIES:
MAP_DATA_DIR = "./map_data/"
MAP_STATUS_DIR = "./map_status/"
INITIAL_USERS_DIR = "./initial_users/"
AGENTS_DIR = "./scenario_agents"

# FILES:
OBS_POINTS_LIST = "obs_points.npy"
POINTS_MATRIX = "points_matrix.npy"
CS_POINTS = "cs_points.npy"
ENODEB_POINT = "eNB_point.npy"

CELLS_MATRIX = "cells_matrix.npy"
OBS_CELLS = "obs_cells.npy"
CS_CELLS = "cs_cells.npy"
ENB_CELLS = "enb_cells.npy"

POINTS_STATUS_MATRIX = "points_status_matrix.npy"
CELLS_STATUS_MATRIX = "cells_status_matrix.npy"
PERCEIVED_STATUS_MATRIX = "perceived_status_matrix.npy"

INITIAL_USERS = "initial_users.npy"
INITIAL_CENTROIDS = "initial_centroids.npy"
INITIAL_CLUSTERS_RADIUSES = "initial_clusters_radiuses.npy"
INITIAL_CLUSTERER = "initial_clusterer.npy"

AGENTS = "agents.npy"


#------------------------Transition_Model------------------------#
PLOTRANGE_X_POS = 8
PLOTRANGE_X_NEG = -8
PLOTRANGE_Y_POS = 8
PLOTRANGE_Y_NEG = -8
PLOTRANGE_Z_POS = 10
PLOTRANGE_Z_NEG = 0